
public class MyLinkedList implements ListInterface {
	
	public class Node{
		Object data;
		Node next;		
		
		public Node (Object data){				// constructor
			this.data = data;
			this.next = null;
		}

		Node (Object item, Node next){  	    // constructor
			this.data = data;
			this.next = next;
		}
	}

	private Node head;
	private int numItems; 

	public MyLinkedList(){
		head = null;
		numItems = 0;
	}
	
	public boolean isEmpty() {
		if (numItems == 0) {
			return true;
		} else {
			return false;
		}		
	}
		
	// Returns the size of the list (number of items in the list)
	public int size() {
		return numItems;
	}
		
	// Adds an Object to the list at the specified index. 
	public void add(int index, Object value) {
	if (index < 0 || index > numItems){
		throw new ListIndexOutOfBoundsException("Index " + index + " is out of range");
		} 
		numItems++;
		Node syllable = new Node(value);
		if (head == null){   // case where list is empty
			head = syllable;
			return;
		} 					
		
		Node curr = head;
		Node prev = null;

		if (index != 0){
			for (int i=0; i<index; i++){ 
				prev = curr;
				curr = curr.next;  
			}
			
			prev.next = syllable;
			syllable.next = curr;
		
		} else {                   // when index = 0
			head = syllable;
			syllable.next = curr;

		}
	}	

	
	// Removes an item from the list at the specified index. 
	public void remove(int index){
		if (index >= 0 && index <= numItems){
			if (index == 0){
				head = head.next;
			} else {
				Node current = head;
				for (int i=0; i<index-1; i++){
					current = current.next;
				}
				current.next = current.next.next;
			}
			numItems--;
		System.out.println("numItems = " + numItems);
		} else {
			throw new ListIndexOutOfBoundsException("Index " + index + " is out of range");
		}
	}
	
	// Removes all the items from the list. 
	public void removeAll(){
		head = null;
		numItems = 0;
	}

	// Returns the Object stored in the list at the specified index. 
	public Object get(int index){
		if(index >= 0 && index < numItems){
			Node current = head;
			int j = 0;
			while(j < index){
				current = current.next;
				j++;
			}
			return current.data;
		
			} else {
				throw new ListIndexOutOfBoundsException("Index " + index + " is out of bounds in get()");
			}
		}

	// Returns the index at which an Object is stored in the list, -1 if it's not in the list.
	public int find(Object o){
		Node N = head;
		int count = 0;
		
		while (N != null){
			if (N.data.equals(o)){
				return count;
			}
			else { 
				N = N.next;
				count++;
			}
		}
		return -1;
	}
}	
public class MySortedLinkedList extends MyLinkedList {

	/* TODO 
	   define the method
	   public void add(Comparable c)
	   that, given a Comparable (an interface type for all Object subclasses that define a compareTo() method), adds it to the 
	   list in sorted order.
	*/

	  	public class Node{
	  		Comparable c;
	  		Node next;

	  		public Node (Comparable i){
	  			c = i;
	  			next = null;
	  		}
	  	}

	  	public MySortedLinkedList(){
	  		head = null;
	  	}

	  	private Node head;	  	
	   	
	   	public void add(Comparable c){
	   		Node newNode = new Node(c);
			if (head == null){         // Checks to see if list is empty
	   			head = newNode;
	   			return;
	   	
	   		} else if (c.compareTo(head.c) < 0){   // If something is in the list check to see if it belongs in front
	   			newNode.next = head;
	   			head = newNode;
	   	
	   		} else {                         // if not
	   			Node after = head.next;
	   			Node prev = head;
	   			
	   			while (after != null){
	   				if (c.compareTo(after.c) < 0){
	   					break;
	   				}
	   				prev = after;
	   				after = after.next;
	   			}
	   		
	   			newNode.next = prev.next;
	   			prev.next = newNode;
	   		}
		}
		
		public String toString(){
			StringBuilder s = new StringBuilder(100);
			Node n = head;
			while (n != null){
				s.append(n.c.toString());
				n = n.next;
			}
			return s.toString();
		}
	
	/* TODO
	   override the method
	   void add(int index, Object o)
	   so that it throws an UnsupportedOperationException with the message "Do not call add(int, Object) on MySortedLinkedList".
	   Directly adding objects at an index would mess up the sorted order.
	*/
	  	public void add(int index, Object o){
	   	  throw new UnsupportedOperationException("Do not call add(int, Object) on MySortedLinkedList");
	  }
}






















/************************************************************************
* Beagan Nguy
* Assignment 2
* CMPS 12B - 02
************************************************************************/
import java.io.*;
import java.util.*;
import java.util.Arrays;
import java.nio.file.Files;
import java.nio.file.Paths;

public class RhymingDict { 	
  

	// Given a pronunciation, get the rhyme group
	// get the more *heavily emphasized vowel* and follwing syllables
	// For "tomato", this is "-ato", and not "-omato", or "-o"
	// Tomato shares a rhyming group with "potato", but not "grow"
	private static String getRhymeGroup(String line) {

		int firstSpace = line.indexOf(" "); 

		String pronunciation = line.substring(firstSpace + 1, line.length());

		int stress0 = pronunciation.indexOf("0");
		int stress1 = pronunciation.indexOf("1");
		int stress2 = pronunciation.indexOf("2");

		if (stress2 >= 0)
			return pronunciation.substring(stress2 - 2, pronunciation.length());
		if (stress1 >= 0)
			return pronunciation.substring(stress1 - 2, pronunciation.length());
		if (stress0 >= 0)
			return pronunciation.substring(stress0 - 2, pronunciation.length());
		
		// No vowels at all? ("hmmm", "mmm", "shh")
		return pronunciation;
	}

	private static String getWord(String line) {
		int firstSpace = line.indexOf(" ");

		String word = line.substring(0, firstSpace);

		return word; 
	}

	// Load the dictionary
	private static String[] loadDictionary() {
		// Load the file and read it

		String[] lines = null; // Array we'll return holding all the lines of the dictionary
		
		try {
			String path = "cmudict/cmudict-short.dict";
			// Creating an array of strings, one for each line in the file
			lines = new String(Files.readAllBytes(Paths.get(path))).split("\\r?\\n");
			
		}
		catch (IOException ex){
			ex.printStackTrace();
		}

		return lines; 
	}

	
	public static void main(String []args) {

		String[] dictionaryLines = loadDictionary(); // store each line of dic into to an array{i}

		/*MyLinkedList dictionarylist = new MyLinkedList();

		for (int i=0; i<dictionaryLines.length; i++){
			dictionarylist.add(i, dictionaryLines[i]);
			System.out.println("index " + i + "= " + dictionarylist.get(i));
		}
				*/
		// List of rhyme groups. The items in this linked list will be RhymeGroupWords. 

		/* TODO: Add in your code to load the dictionary into your linked lists. Remember that rhymeGroups is a 
		   list of RhymeGroupWords. Inside each of this objects is another linked list which is a list of words within the same
		   rhyme group. I would recommend first getting this working with MyLinkedList for both lists (rhyme groups and 
		   word lists) then get it working using MySortedLinkedList for the word groups. */

		ListInterface rhymeGroups = new MyLinkedList(); 
			
		int rGIndex = 0; 

		for (int i=0; i<dictionaryLines.length-1; i++){     // Loop through the lines in dictionary Lines
			
			String rg = (getRhymeGroup(dictionaryLines[i]));
			
			if (i == 0){								    // First Rhyme Group
				rhymeGroups.add(0, getRhymeGroup(dictionaryLines[0]));
			
			} else if (rhymeGroups.find(rg) == -1){    // If Object(Rhyme Group) is not Found 
				rGIndex++;
				rhymeGroups.add(rGIndex, rg);
			}
		}
		
		for (int i=0; i<rhymeGroups.size(); i++){       // Find same rhyme group words
			
			MySortedLinkedList RhymeGroupWords = new MySortedLinkedList();

			for (int a=0; a<dictionaryLines.length; a++){  
				String rgs = getRhymeGroup(dictionaryLines[a]);
				
				if (rhymeGroups.get(i).toString().equals(rgs)){   
					RhymeGroupWords.add(getWord(dictionaryLines[a]));
				}
			}
		}

		/* End TODO for adding dictionary in rhymeGroups. */

		// This code prints out the rhyme groups that have been loaded above. 
		for(int i =0; i < rhymeGroups.size(); i++) {
			RhymeGroupWords rg = (RhymeGroupWords) rhymeGroups.get(i);
			System.out.print(rg.getRhymeGroup() + ": ");
			System.out.println(rg.getWordList());
		} 

		/* TODO: Add the code here to iterate through pairs of arguments, testing to see if they are in the same rhyme group or not.
		*/
	}
}
